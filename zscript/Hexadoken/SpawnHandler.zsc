//-------------------------------------------------
// Huge credits to FDA for the Radtech Event handler which this is based off of. It's been incredibly helpful.
//-------------------------------------------------

// Struct for itemspawn information. 
class HexaSpawnItem play {
    // ID by string for spawner
    string spawnName;
    
    // ID by string for spawnees
    Array<HexaSpawnItemEntry> spawnReplaces;
    
    // Whether or not to persistently spawn.
    bool isPersistent;
    
	// Whether or not to replace the original item.
    bool replaceItem;

    string toString() {

        let replacements = "[";
        if (spawnReplaces.size()) {
            replacements = replacements..spawnReplaces[0].toString();

			foreach (spawnReplace : spawnReplaces) replacements = replacements..", "..spawnReplace.toString();
        }
        replacements = replacements.."]";


        return String.format("{ spawnName=%s, spawnReplaces=%s, isPersistent=%b, replaceItem=%b }", spawnName, replacements, isPersistent, replaceItem);
    }
}

class HexaSpawnItemEntry play {
    string name;
    int    chance;

    string toString() {
        return String.format("{ name=%s, chance=%s }", name, chance >= 0 ? "1/"..(chance + 1) : "never");
    }
}

// Struct for passing useinformation to ammunition. 
class HexaSpawnAmmo play {
    // ID by string for the header ammo.
    string ammoName;
    
    // ID by string for weapons using that ammo.
    Array<string> weaponNames;
    
    string toString() {

        let weapons = "[";
        if (weaponNames.size()) {
            weapons = weapons..weaponNames[0];

			foreach (weaponName : weaponNames) weapons = weapons..", "..weaponName;
        }
        weapons = weapons.."]";

        return String.format("{ ammoName=%s, weaponNames=%s }", ammoName, weapons);
    }
}



// One handler to rule them all. 
class HexaDokenHandler : EventHandler {
    
    // List of persistent classes to completely ignore. 
    // This -should- mean this mod has no performance impact. 
    static const string blacklist[] = {
        "HDSmoke",
        "BloodTrail",
        "CheckPuff",
        "WallChunk",
        "HDBulletPuff",
        "HDFireballTail",
        "ReverseImpBallTail",
        "HDSmokeChunk",
        "ShieldSpark",
        "HDFlameRed",
        "HDMasterBlood",
        "PlantBit",
        "HDBulletActor",
        "HDLadderSection"
    };

    // List of weapon-ammo associations.
    // Used for ammo-use association on ammo spawn (happens very often). 
    array<HexaSpawnAmmo> ammoSpawnList;
    
    // List of item-spawn associations.
    // used for item-replacement on mapload. 
    array<HexaSpawnItem> itemSpawnList;
    
    bool cvarsAvailable;
    
    // appends an entry to itemSpawnList;
    void addItem(string name, Array<HexaSpawnItemEntry> replacees, bool persists, bool rep=true) {

        if (hd_debug) {
            let msg = "Adding "..(persists ? "Persistent" : "Non-Persistent").." Replacement Entry for "..name..": ["..replacees[0].toString();

			if (replacees.size() > 1) foreach (replacee : replacees) msg = msg..", "..replacee.toString();

            console.printf(msg.."]");
        }

        // Creates a new struct;
        HexaSpawnItem spawnee = HexaSpawnItem(new('HexaSpawnItem'));
        
        // Populates the struct with relevant information,
        spawnee.spawnName = name;
        spawnee.isPersistent = persists;
        spawnee.replaceItem = rep;
        
		foreach (replacee : replacees) spawnee.spawnReplaces.push(replacee);
        
        // Pushes the finished struct to the array. 
        itemSpawnList.push(spawnee);
    }

    HexaSpawnItemEntry addItemEntry(string name, int chance) {
        // Creates a new struct;
        HexaSpawnItemEntry spawnee = HexaSpawnItemEntry(new('HexaSpawnItemEntry'));
        spawnee.name = name.makeLower();
        spawnee.chance = chance;
        return spawnee;
    }

    // appends an entry to ammoSpawnList;
    void addAmmo(string name, Array<string> weapons) {
    
        // Creates a new struct;
        HexaSpawnAmmo spawnee = HexaSpawnAmmo(new('HexaSpawnAmmo'));
        spawnee.ammoName = name.makeLower();
        
        // Populates the struct with relevant information,
		foreach (weapon : weapons) spawnee.weaponNames.push(weapon.makeLower());
        
        // Pushes the finished struct to the array. 
        ammoSpawnList.push(spawnee);
    }
    

    // Populates the replacement and association arrays. 
    void init() {

        cvarsAvailable = true;

        //------------
        // Ammunition
        //------------

        // 7mm Clips
        Array<string> wep_7mmClip;
        wep_7mmClip.push("NoScopeBoss");
        addAmmo('HD7mClip', wep_7mmClip);

        // 7mm
        Array<string> wep_7mm;
        wep_7mm.push("NoScopeBoss");
        wep_7mm.push("BossRifleButItsTheWorst");
        addAmmo('SevenMilAmmo', wep_7mm);
        
        // 7mm Recast
        Array<string> wep_7mmR;
        wep_7mmR.push("NoScopeBoss");
        addAmmo('SevenMilAmmoRecast', wep_7mmR);

        // 7mm Brass
        Array<string> wep_7mmB;
        wep_7mmB.push("SpeedRunLoader");
        addAmmo('SevenMilBrass', wep_7mmB);

        // 9mm
        Array<string> wep_9mm;
        wep_9mm.push("BossRifleButIts9mm");
        addAmmo('HDPistolAmmo', wep_9mm);

        // 4mm
        Array<string> wep_4mm;
        wep_4mm.push("BossRifleButIts4mm");
        addAmmo('FourMilAmmo', wep_4mm);
        wep_4mm.push("SpeedRunLoader");
        addAmmo('FourMilAmmo', wep_4mm);

        // 5mm
        Array<string> wep_5mm;
        wep_5mm.push("BossRifleButItsFuckingPink");
        addAmmo('HD5MM_Ammo', wep_5mm);

        // .50 OMG
        Array<string> wep_50OMG;
        wep_50OMG.push("BogRifle");
        addAmmo('HD50OMGAmmo', wep_50OMG);

        // .30-06
        Array<string> wep_3006;
        wep_3006.push("M1Garand");
        addAmmo('ThirtyAughtSixAmmo', wep_3006);

        // 12 Gauge Shells
        Array<string> wep_Shells;
        wep_Shells.push("Bossmerg");
        addAmmo('HDShellAmmo', wep_Shells);

        //------------
        // Weaponry
        //------------

        // No-scope Boss Rifle
        Array<HexaSpawnItemEntry> spawns_NoScopeBoss;
        spawns_NoScopeBoss.push(addItemEntry('BossRifle', nsb_boss_spawn_bias));
        addItem('NoScopeBossSpawner', spawns_NoScopeBoss, nsb_persistent_spawning);

        // Bossmerg
        Array<HexaSpawnItemEntry> spawns_Bossmerg;
        spawns_Bossmerg.push(addItemEntry('Hunter', bas_hunter_spawn_bias));
        addItem('Bossmerg', spawns_Bossmerg, bas_persistent_spawning);

        // M1 Garand
        Array<HexaSpawnItemEntry> spawns_Garand;
        spawns_Garand.push(addItemEntry('LiberatorRandom', gar_shellbox_spawn_bias));
        addItem('HDGarandRandom', spawns_Garand, gar_persistent_spawning);

        // .50 OMG Boss Rifle
        Array<HexaSpawnItemEntry> spawns_BogRifle;
        spawns_BogRifle.push(addItemEntry('ThunderBuster', bog_plasma_spawn_bias));
        spawns_BogRifle.push(addItemEntry('Slayer', bog_ssg_spawn_bias));
        spawns_BogRifle.push(addItemEntry('Vulcanette', bog_chaingun_spawn_bias));
        addItem('BogRifleSpawner', spawns_BogRifle, bog_persistent_spawning);

        //------------
        // Items
        //------------

        Array<HexaSpawnItemEntry> spawns_scanner;
		spawns_scanner.push(additementry('PortableStimpack', dms_stimpack_bias));
		spawns_scanner.push(additementry('PortableMedikit', dms_medikit_bias));
        addItem('HDScanner', spawns_scanner, dms_persistent_spawning);
    }
    
    // Random stuff, stores it and forces negative values just to be 0.
    bool giveRandom(int chance) {
        if (chance > -1) {
            let result = random(0, chance);

			if (hd_debug) console.printf("Rolled a "..(result + 1).." out of "..(chance + 1));

            return result == 0;
        }

        return false;
    }

    // Tries to create the item via random spawning.
    bool tryCreateItem(Actor thing, string spawnName, int chance, bool rep) {
        if (giveRandom(chance)) {
            if (Actor.Spawn(spawnName, thing.pos) && rep) {
                if (hd_debug) console.printf(thing.getClassName().." -> "..spawnName);

                thing.destroy();

                return true;
            }
        }

        return false;
    }
    
	override void worldThingSpawned(WorldEvent e) {
        // Populates the main arrays if they haven't been already. 
        if (!cvarsAvailable) init();

        // If thing spawned doesn't exist, quit
		if (!e.thing) return;

        // If thing spawned is blacklisted, quit
		foreach (bl : blacklist) if (e.thing is bl) return;

		string candidateName = e.thing.getClassName();
		candidateName = candidateName.makeLower();
        
        // Pointers for specific classes.
		let ammo = HDAmmo(e.thing);
        
        // If the thing spawned is an ammunition, add any and all items that can use this.
        if (ammo) handleAmmoUses(ammo, candidateName);

        // Return if range before replacing things.
        if (level.MapName ~== "RANGE") return;

        handleWeaponReplacements(e.thing, ammo, candidateName);
    }

    private void handleAmmoUses(HDAmmo ammo, string candidateName) {
		foreach (ammoSpawn : ammoSpawnList) if (candidateName == ammoSpawn.ammoName) ammo.itemsThatUseThis.copy(ammoSpawn.weaponNames);
    }

    private void handleWeaponReplacements(Actor thing, HDAmmo ammo, string candidateName) {
        
        // Checks if the level has been loaded more than 1 tic.
        bool prespawn = !(level.maptime > 1);

        // Iterates through the list of item candidates for e.thing.
		foreach (itemSpawn : itemSpawnList) {
            
            // if an item is owned or is an ammo (doesn't retain owner ptr), 
            // do not replace it. 
            let item = Inventory(thing);
            if ((prespawn || itemSpawn.isPersistent) && (!(item && item.owner) && (!ammo || prespawn))) {
				foreach (spawnReplace : itemSpawn.spawnReplaces) {
					if (spawnReplace.name == candidateName) {
						if (hd_debug) console.printf("Attempting to replace "..candidateName.." with "..itemSpawn.spawnName.."...");

                        if (tryCreateItem(thing, itemSpawn.spawnName, spawnReplace.chance, itemSpawn.replaceItem)) return;
                    }
                }
            }
        }
    }
}
